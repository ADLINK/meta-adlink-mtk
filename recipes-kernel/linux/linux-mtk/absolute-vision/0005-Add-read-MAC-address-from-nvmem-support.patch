From ff169caa50d8c22fe2cf7af8d522b6f8f28e5827 Mon Sep 17 00:00:00 2001
From: "deepak.s" <deepak.s@adlinktech.com>
Date: Thu, 31 Jul 2025 13:29:43 +0530
Subject: [PATCH] Add read MAC address from nvmem support

---
 .../ethernet/stmicro/stmmac/stmmac_platform.c | 92 +++++++++++++++++--
 1 file changed, 85 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
index 30d5e635190e..afb8116aed1b 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -20,6 +20,72 @@
 #include "stmmac.h"
 #include "stmmac_platform.h"
 
+#include <linux/nvmem-consumer.h>  /* for nvmem_cell_get, etc. */
+#include <linux/etherdevice.h>
+
+static int stmmac_get_mac_from_nvmem(struct device *dev, u8 *mac_addr)
+{
+    struct nvmem_cell *cell0, *cell1;
+    size_t len0, len1;
+    void *buf0, *buf1;
+    int ret = 0;
+
+    cell0 = nvmem_cell_get(dev, "mac-part0");
+    if (IS_ERR(cell0))
+        return PTR_ERR(cell0);
+
+    buf0 = nvmem_cell_read(cell0, &len0);
+    nvmem_cell_put(cell0);
+    if (IS_ERR(buf0))
+        return PTR_ERR(buf0);
+
+    cell1 = nvmem_cell_get(dev, "mac-part1");
+    if (IS_ERR(cell1)) {
+        ret = PTR_ERR(cell1);
+        goto free_buf0;
+    }
+
+    buf1 = nvmem_cell_read(cell1, &len1);
+    nvmem_cell_put(cell1);
+    if (IS_ERR(buf1)) {
+        ret = PTR_ERR(buf1);
+        goto free_buf0;
+    }
+
+    if (len0 < 4 || len1 < 2) {
+        dev_err(dev, "Invalid MAC from nvmem: insufficient data (len0=%zu, len1=%zu)\n", len0, len1);
+        ret = -EINVAL;
+        goto free_buf1;
+    }
+
+    mac_addr[0] = ((u8 *)buf0)[0];
+    mac_addr[1] = ((u8 *)buf0)[1];
+    mac_addr[2] = ((u8 *)buf0)[2];
+    mac_addr[3] = ((u8 *)buf0)[3];
+    mac_addr[4] = ((u8 *)buf1)[0];
+    mac_addr[5] = ((u8 *)buf1)[1];
+
+    if (is_zero_ether_addr(mac_addr)) {
+        dev_err(dev, "Invalid MAC from nvmem: all zeros (%pM), skipping\n", mac_addr);
+        ret = -EINVAL;
+        goto free_buf1;
+    }
+
+    if (is_multicast_ether_addr(mac_addr)) {
+        dev_err(dev, "Invalid MAC from nvmem: multicast address (%pM), skipping\n", mac_addr);
+        ret = -EINVAL;
+        goto free_buf1;
+    }
+
+    dev_info(dev, "Read valid MAC from nvmem: %pM\n", mac_addr);
+
+free_buf1:
+    kfree(buf1);
+free_buf0:
+    kfree(buf0);
+    return ret;
+}
+
 #ifdef CONFIG_OF
 
 /**
@@ -409,13 +475,25 @@ stmmac_probe_config_dt(struct platform_device *pdev, u8 *mac)
 	if (!plat)
 		return ERR_PTR(-ENOMEM);
 
-	rc = of_get_mac_address(np, mac);
-	if (rc) {
-		if (rc == -EPROBE_DEFER)
-			return ERR_PTR(rc);
-
-		eth_zero_addr(mac);
-	}
+       if (stmmac_get_mac_from_nvmem(&pdev->dev, mac)) {
+               rc = of_get_mac_address(np, mac);
+               if (rc) {
+                       if (rc == -EPROBE_DEFER)
+                               return ERR_PTR(rc);
+                       dev_warn(&pdev->dev, "Failed to get MAC from nvmem and device tree, using zero address\n");
+                       eth_zero_addr(mac);
+               }
+       } else {
+               dev_info(&pdev->dev, "Successfully read MAC address from nvmem: %pM\n", mac);
+        }
+
+       /* rc = of_get_mac_address(np, mac); */
+       /* if (rc) { */
+       /*      if (rc == -EPROBE_DEFER) */
+       /*              return ERR_PTR(rc); */
+
+       /*      eth_zero_addr(mac); */
+       /* } */
 
 	phy_mode = device_get_phy_mode(&pdev->dev);
 	if (phy_mode < 0)
-- 
2.49.0

