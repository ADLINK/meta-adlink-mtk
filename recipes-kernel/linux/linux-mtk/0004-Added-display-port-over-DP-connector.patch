From db3fe5c9e2b221b136dde2be74348eddb18087f5 Mon Sep 17 00:00:00 2001
From: aravindlal <aravindlal.mh@adlinktech.com>
Date: Wed, 25 Jun 2025 11:10:28 +0530
Subject: [PATCH] Added display port over DP connector

---
 drivers/gpu/drm/mediatek/mtk_dp.c | 307 +++++++++++++++++-------------
 1 file changed, 174 insertions(+), 133 deletions(-)

diff --git a/drivers/gpu/drm/mediatek/mtk_dp.c b/drivers/gpu/drm/mediatek/mtk_dp.c
index 3e3a5915dd26..b56265f19604 100644
--- a/drivers/gpu/drm/mediatek/mtk_dp.c
+++ b/drivers/gpu/drm/mediatek/mtk_dp.c
@@ -77,7 +77,6 @@ struct mtk_dp_train_info {
 
 struct mtk_dp_audio_cfg {
 	bool detect_monitor;
-	int sad_count;
 	int sample_rate;
 	int word_length_bits;
 	int channels;
@@ -86,7 +85,7 @@ struct mtk_dp_audio_cfg {
 struct mtk_dp_info {
 	enum dp_pixelformat format;
 	struct videomode vm;
-	struct mtk_dp_audio_cfg audio_cur_cfg;
+	struct mtk_dp_audio_cfg audio_caps;
 };
 
 struct mtk_dp_efuse_fmt {
@@ -403,6 +402,11 @@ static struct regmap_config mtk_dp_regmap_config = {
 	.name = "mtk-dp-registers",
 };
 
+static bool mtk_dp_is_edp(struct mtk_dp *mtk_dp)
+{
+	return mtk_dp->next_bridge != NULL;
+}
+
 static struct mtk_dp *mtk_dp_from_bridge(struct drm_bridge *b)
 {
 	return container_of(b, struct mtk_dp, bridge);
@@ -610,7 +614,11 @@ static void mtk_dp_setup_encoder(struct mtk_dp *mtk_dp)
 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_3364,
 			   FIFO_READ_START_POINT_DP_ENC1_P0_VAL << 12,
 			   FIFO_READ_START_POINT_DP_ENC1_P0_MASK);
-	mtk_dp_write(mtk_dp, MTK_DP_ENC1_P0_3368, DP_ENC1_P0_3368_VAL);
+	mtk_dp_write(mtk_dp, MTK_DP_ENC1_P0_3368, 
+			1 << VIDEO_SRAM_FIFO_CNT_RESET_SEL_DP_ENC1_P0 |
+			1 << VIDEO_STABLE_CNT_THRD_DP_ENC1_P0 |
+			     BIT(SDP_DP13_EN_DP_ENC1_P0) |
+			     1 << BS2BS_MODE_DP_ENC1_P0);
 }
 
 static void mtk_dp_pg_enable(struct mtk_dp *mtk_dp, bool enable)
@@ -653,14 +661,12 @@ static void mtk_dp_audio_setup_channels(struct mtk_dp *mtk_dp,
 				      AUDIO_8CH_EN_DP_ENC0_P0_MASK;
 		break;
 	}
-	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3088,
-			   channel_enable_bits | AU_EN_DP_ENC0_P0,
-			   AUDIO_2CH_SEL_DP_ENC0_P0_MASK |
-			   AUDIO_2CH_EN_DP_ENC0_P0_MASK |
-			   AUDIO_8CH_SEL_DP_ENC0_P0_MASK |
-			   AUDIO_8CH_EN_DP_ENC0_P0_MASK |
-			   AU_EN_DP_ENC0_P0);
-
+	mtk_dp_update_bits(
+		mtk_dp, MTK_DP_ENC0_P0_3088,
+		channel_enable_bits | AU_EN_DP_ENC0_P0_MASK,
+		AUDIO_2CH_SEL_DP_ENC0_P0_MASK | AUDIO_2CH_EN_DP_ENC0_P0_MASK |
+			AUDIO_8CH_SEL_DP_ENC0_P0_MASK |
+			AUDIO_8CH_EN_DP_ENC0_P0_MASK | AU_EN_DP_ENC0_P0_MASK);
 	/* audio channel count change reset */
 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC1_P0_33F4, 0, DP_ENC_DUMMY_RW_1);
 
@@ -673,55 +679,55 @@ static void mtk_dp_audio_setup_channels(struct mtk_dp *mtk_dp,
 static void mtk_dp_audio_channel_status_set(struct mtk_dp *mtk_dp,
 					    struct mtk_dp_audio_cfg *cfg)
 {
-	struct snd_aes_iec958 iec = { 0 };
+	union mtk_dp_audio_channel_status channel_status;
+
+	memset(&channel_status, 0, sizeof(channel_status));
 
 	switch (cfg->sample_rate) {
 	case 32000:
-		iec.status[3] = IEC958_AES3_CON_FS_32000;
+		channel_status.iec.sampling_freq = 3;
 		break;
 	case 44100:
-		iec.status[3] = IEC958_AES3_CON_FS_44100;
+		channel_status.iec.sampling_freq = 0;
 		break;
 	case 48000:
-		iec.status[3] = IEC958_AES3_CON_FS_48000;
+		channel_status.iec.sampling_freq = 2;
 		break;
 	case 88200:
-		iec.status[3] = IEC958_AES3_CON_FS_88200;
+		channel_status.iec.sampling_freq = 8;
 		break;
 	case 96000:
-		iec.status[3] = IEC958_AES3_CON_FS_96000;
+		channel_status.iec.sampling_freq = 0xA;
 		break;
 	case 192000:
-		iec.status[3] = IEC958_AES3_CON_FS_192000;
+		channel_status.iec.sampling_freq = 0xE;
 		break;
 	default:
-		iec.status[3] = IEC958_AES3_CON_FS_NOTID;
+		channel_status.iec.sampling_freq = 0x1;
 		break;
 	}
 
 	switch (cfg->word_length_bits) {
 	case 16:
-		iec.status[4] = IEC958_AES4_CON_WORDLEN_20_16;
+		channel_status.iec.word_len = 0x02;
 		break;
 	case 20:
-		iec.status[4] = IEC958_AES4_CON_WORDLEN_20_16 |
-				IEC958_AES4_CON_MAX_WORDLEN_24;
+		channel_status.iec.word_len = 0x03;
 		break;
 	case 24:
-		iec.status[4] = IEC958_AES4_CON_WORDLEN_24_20 |
-				IEC958_AES4_CON_MAX_WORDLEN_24;
+		channel_status.iec.word_len = 0x0B;
 		break;
-	default:
-		iec.status[4] = IEC958_AES4_CON_WORDLEN_NOTID;
 	}
 
 	/* IEC 60958 consumer channel status bits */
 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_308C,
-			   0, CH_STATUS_0_DP_ENC0_P0_MASK);
+			   channel_status.buf[1] << 8 | channel_status.buf[0],
+			   CH_STATUS_0_DP_ENC0_P0_MASK);
 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3090,
-			   iec.status[3] << 8, CH_STATUS_1_DP_ENC0_P0_MASK);
-	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3094,
-			   iec.status[4], CH_STATUS_2_DP_ENC0_P0_MASK);
+			   channel_status.buf[3] << 8 | channel_status.buf[2],
+			   CH_STATUS_1_DP_ENC0_P0_MASK);
+	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_3094, channel_status.buf[4],
+			    CH_STATUS_2_DP_ENC0_P0_MASK);
 }
 
 static void mtk_dp_audio_sdp_asp_set_channels(struct mtk_dp *mtk_dp,
@@ -735,8 +741,14 @@ static void mtk_dp_audio_sdp_asp_set_channels(struct mtk_dp *mtk_dp,
 static void mtk_dp_audio_set_divider(struct mtk_dp *mtk_dp)
 {
 	mtk_dp_update_bits(mtk_dp, MTK_DP_ENC0_P0_30BC,
-			   mtk_dp->data->audio_m_div2_bit,
-			   AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_MASK);
+			AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_DIV_2,   
+			AUDIO_M_CODE_MULT_DIV_SEL_DP_ENC0_P0_MASK);
+}
+
+static bool mtk_dp_plug_state(struct mtk_dp *mtk_dp)
+{
+	return !!(mtk_dp_read(mtk_dp, MTK_DP_TRANS_P0_3414) &
+		  HPD_DB_DP_TRANS_P0_MASK);
 }
 
 static void mtk_dp_sdp_trigger_aui(struct mtk_dp *mtk_dp)
@@ -897,11 +909,15 @@ static int mtk_dp_aux_do_transfer(struct mtk_dp *mtk_dp, bool is_read, u8 cmd,
 				  u32 addr, u8 *buf, size_t length, u8 *reply_cmd)
 {
 	int ret;
-
+ 	u32 reply_cmd;
+ 
+	dev_dbg(mtk_dp->dev, "AUX transfer is_read(%d) cmd(%d) addr(0x%x) length(%zu)\n",
+		is_read, cmd, addr, length);
 	if (is_read && (length > DP_AUX_MAX_PAYLOAD_BYTES ||
-			(cmd == DP_AUX_NATIVE_READ && !length)))
-		return -EINVAL;
-
+			(cmd == DP_AUX_NATIVE_READ && !length))) {
+		dev_err(mtk_dp->dev, "AUX err: read lenth > 16 or length = 0\n");
+				return -EINVAL;
+	}
 	if (!is_read)
 		mtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3704,
 				   AUX_TX_FIFO_NEW_MODE_EN_AUX_TX_P0,
@@ -918,9 +934,10 @@ static int mtk_dp_aux_do_transfer(struct mtk_dp *mtk_dp, bool is_read, u8 cmd,
 		if (length)
 			mtk_dp_aux_fill_write_fifo(mtk_dp, buf, length);
 
-		mtk_dp_update_bits(mtk_dp, MTK_DP_AUX_P0_3704,
-				   AUX_TX_FIFO_WDATA_NEW_MODE_T_AUX_TX_P0_MASK,
-				   AUX_TX_FIFO_WDATA_NEW_MODE_T_AUX_TX_P0_MASK);
+	mtk_dp_update_bits(
+			mtk_dp, MTK_DP_AUX_P0_3704,
+			AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_MASK,
+			AUX_TX_FIFO_WRITE_DATA_NEW_MODE_TOGGLE_AUX_TX_P0_MASK);
 	}
 
 	mtk_dp_aux_request_ready(mtk_dp);
@@ -1155,7 +1172,7 @@ static void mtk_dp_get_calibration_data(struct mtk_dp *mtk_dp)
 	u32 *cal_data = mtk_dp->cal_data;
 	u32 *buf;
 	int i;
-	size_t len = 0;
+	size_t len;
 
 	cell = nvmem_cell_get(dev, "dp_calibration_data");
 	if (IS_ERR(cell)) {
@@ -1390,7 +1407,10 @@ static void mtk_dp_power_disable(struct mtk_dp *mtk_dp)
 	mtk_dp_write(mtk_dp, MTK_DP_TOP_PWR_STATE, 0);
 
 	mtk_dp_update_bits(mtk_dp, MTK_DP_0034,
-			   DA_CKM_CKTX0_EN_FORCE_EN, DA_CKM_CKTX0_EN_FORCE_EN);
+			   DA_CKM_CKTX0_EN_FORCE_EN| DA_CKM_CKTX0_EN_FORCE_EN |
+			    DA_CKM_BIAS_EN_FORCE_VAL |
+			     DA_XTP_GLB_LDO_EN_FORCE_VAL |
+			     DA_XTP_GLB_AVD10_ON_FORCE_VAL);
 
 	/* Disable RX */
 	mtk_dp_write(mtk_dp, MTK_DP_1040, 0);
@@ -1776,12 +1796,47 @@ static bool mtk_dp_edid_parse_audio_capabilities(struct mtk_dp *mtk_dp,
 	if (!mtk_dp->data->audio_supported)
 		return false;
 
-	if (mtk_dp->info.audio_cur_cfg.sad_count <= 0) {
+	struct cea_sad *sads;
+	int sad_count;
+	int i;
+	int ret = 0;
+
+	mutex_lock(&mtk_dp->edid_lock);
+	if (!mtk_dp->edid) {
+		mutex_unlock(&mtk_dp->edid_lock);
+		dev_err(mtk_dp->dev, "EDID not found!\n");
+		return -EINVAL;
+	}
+
+	sad_count = drm_edid_to_sad(mtk_dp->edid, &sads);
+	mutex_unlock(&mtk_dp->edid_lock);
+	if (sad_count <= 0) {
 		drm_info(mtk_dp->drm_dev, "The SADs is NULL\n");
-		return false;
+		return 0;
+ 	}
+ 
+	for (i = 0; i < sad_count; i++) {
+		int sample_rate;
+		int word_length;
+		// Only PCM supported at the moment
+		if (sads[i].format != HDMI_AUDIO_CODING_TYPE_PCM)
+			continue;
+
+		sample_rate = drm_cea_sad_get_sample_rate(&sads[i]);
+		word_length =
+			drm_cea_sad_get_uncompressed_word_length(&sads[i]);
+		if (sample_rate <= 0 || word_length <= 0)
+			continue;
+
+		cfg->channels = sads[i].channels;
+		cfg->word_length_bits = word_length;
+		cfg->sample_rate = sample_rate;
+		ret = 1;
+		break;
 	}
+	kfree(sads);
 
-	return true;
+	return ret;
 }
 
 static void mtk_dp_train_change_mode(struct mtk_dp *mtk_dp)
@@ -1790,6 +1845,7 @@ static void mtk_dp_train_change_mode(struct mtk_dp *mtk_dp)
 	mtk_dp_reset_swing_pre_emphasis(mtk_dp);
 }
 
+
 static int mtk_dp_training(struct mtk_dp *mtk_dp)
 {
 	int ret;
@@ -1952,6 +2008,7 @@ static void mtk_dp_init_port(struct mtk_dp *mtk_dp)
 static irqreturn_t mtk_dp_hpd_event_thread(int hpd, void *dev)
 {
 	struct mtk_dp *mtk_dp = dev;
+	int event;
 	unsigned long flags;
 	u32 status;
 
@@ -2102,7 +2159,8 @@ static enum drm_connector_status mtk_dp_bdg_detect(struct drm_bridge *bridge)
 	enum drm_connector_status ret = connector_status_disconnected;
 	bool enabled = mtk_dp->enabled;
 	u8 sink_count = 0;
-
+	
+	pr_notice("xinlei: %s enter", __func__);
 	if (!mtk_dp->train_info.cable_plugged_in)
 		return ret;
 
@@ -2117,12 +2175,14 @@ static enum drm_connector_status mtk_dp_bdg_detect(struct drm_bridge *bridge)
 	 * whether we connect to a sink device.
 	 */
 	drm_dp_dpcd_readb(&mtk_dp->aux, DP_SINK_COUNT, &sink_count);
-	if (DP_GET_SINK_COUNT(sink_count))
+	if (DP_GET_SINK_COUNT(sink_count)){
 		ret = connector_status_connected;
-
+		pr_notice("xinlei: %s mid, ret = %d", __func__, ret);
+}
 	if (!enabled)
 		mtk_dp_aux_panel_poweron(mtk_dp, false);
 
+		pr_notice("xinlei: %s exit, ret = %d", __func__, ret);
 	return ret;
 }
 
@@ -2132,7 +2192,7 @@ static struct edid *mtk_dp_get_edid(struct drm_bridge *bridge,
 	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
 	bool enabled = mtk_dp->enabled;
 	struct edid *new_edid = NULL;
-	struct mtk_dp_audio_cfg *audio_caps = &mtk_dp->info.audio_cur_cfg;
+	
 
 	if (!enabled) {
 		drm_atomic_bridge_chain_pre_enable(bridge, connector->state->state);
@@ -2151,14 +2211,6 @@ static struct edid *mtk_dp_get_edid(struct drm_bridge *bridge,
 		new_edid = NULL;
 	}
 
-	if (new_edid) {
-		struct cea_sad *sads;
-
-		audio_caps->sad_count = drm_edid_to_sad(new_edid, &sads);
-		kfree(sads);
-
-		audio_caps->detect_monitor = drm_detect_monitor_audio(new_edid);
-	}
 
 	if (!enabled) {
 		mtk_dp_aux_panel_poweron(mtk_dp, false);
@@ -2179,6 +2231,7 @@ static ssize_t mtk_dp_aux_transfer(struct drm_dp_aux *mtk_aux,
 
 	if (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP &&
 	    !mtk_dp->train_info.cable_plugged_in) {
+		dev_err(mtk_dp->dev, "AUX err: DP noconnected\n");
 		ret = -EIO;
 		goto err;
 	}
@@ -2250,16 +2303,21 @@ static void mtk_dp_poweroff(struct mtk_dp *mtk_dp)
 	phy_exit(mtk_dp->phy);
 }
 
-static int mtk_dp_bridge_attach(struct drm_bridge *bridge,
+	static int mtk_dp_bridge_attach(struct drm_bridge *bridge,
 				enum drm_bridge_attach_flags flags)
 {
 	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
 	int ret;
-
+	
+	pr_notice("xinlei: %s enter", __func__);
 	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
 		dev_err(mtk_dp->dev, "Driver does not provide a connector!");
 		return -EINVAL;
 	}
+	
+		ret = mtk_dp_poweron(mtk_dp);
+		if (ret)
+			return ret;
 
 	mtk_dp->aux.drm_dev = bridge->dev;
 	ret = drm_dp_aux_register(&mtk_dp->aux);
@@ -2269,9 +2327,6 @@ static int mtk_dp_bridge_attach(struct drm_bridge *bridge,
 		return ret;
 	}
 
-	ret = mtk_dp_poweron(mtk_dp);
-	if (ret)
-		goto err_aux_register;
 
 	if (mtk_dp->next_bridge) {
 		ret = drm_bridge_attach(bridge->encoder, mtk_dp->next_bridge,
@@ -2284,13 +2339,14 @@ static int mtk_dp_bridge_attach(struct drm_bridge *bridge,
 	}
 
 	mtk_dp->drm_dev = bridge->dev;
+	
 
 	if (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP) {
 		irq_clear_status_flags(mtk_dp->irq, IRQ_NOAUTOEN);
 		enable_irq(mtk_dp->irq);
 		mtk_dp_hwirq_enable(mtk_dp, true);
 	}
-
+	pr_notice("xinlei: %s exit", __func__);
 	return 0;
 
 err_bridge_attach:
@@ -2317,45 +2373,50 @@ static void mtk_dp_bridge_atomic_enable(struct drm_bridge *bridge,
 					struct drm_bridge_state *old_state)
 {
 	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
-	int ret;
+	struct drm_connector *conn;
+	int ret = 0;
+	int i;
 
-	mtk_dp->conn = drm_atomic_get_new_connector_for_encoder(old_state->base.state,
-								bridge->encoder);
-	if (!mtk_dp->conn) {
-		drm_err(mtk_dp->drm_dev,
+	pr_notice("xinlei: %s enter", __func__);
+	conn = drm_atomic_get_new_connector_for_encoder(old_state->base.state,
+							bridge->encoder);
+	if (!conn) {	
+	drm_err(mtk_dp->drm_dev,
 			"Can't enable bridge as connector is missing\n");
 		return;
 	}
+	
+	memcpy(mtk_dp->connector_eld, conn->eld, MAX_ELD_BYTES);
 
 	mtk_dp_aux_panel_poweron(mtk_dp, true);
 
-	/* Training */
-	ret = mtk_dp_training(mtk_dp);
-	if (ret) {
-		drm_err(mtk_dp->drm_dev, "Training failed, %d\n", ret);
-		goto power_off_aux;
-	}
-
 	ret = mtk_dp_video_config(mtk_dp);
 	if (ret)
 		goto power_off_aux;
 
 	mtk_dp_video_enable(mtk_dp, true);
-
-	mtk_dp->audio_enable =
-		mtk_dp_edid_parse_audio_capabilities(mtk_dp,
-						     &mtk_dp->info.audio_cur_cfg);
-	if (mtk_dp->audio_enable) {
-		mtk_dp_audio_setup(mtk_dp, &mtk_dp->info.audio_cur_cfg);
-		mtk_dp_audio_mute(mtk_dp, false);
-	} else {
-		memset(&mtk_dp->info.audio_cur_cfg, 0,
-		       sizeof(mtk_dp->info.audio_cur_cfg));
-	}
+	
+	//training
+	for (i = 0; i < 50; i++) {
+		ret = mtk_dp_train_handler(mtk_dp);
+		if (ret) {
+			drm_err(mtk_dp->drm_dev, "Train handler failed %d\n",
+				ret);
+			return;
+		}
+	ret = mtk_dp_state_handler(mtk_dp);
+		if (ret) {
+			drm_err(mtk_dp->drm_dev, "State handler failed %d\n",
+				ret);
+			return;
+		}
 
 	mtk_dp->enabled = true;
 	mtk_dp_update_plugged_status(mtk_dp);
-
+	
+	dev_dbg(mtk_dp->dev, "DPTX calc pixel clock = %d MHz\n",
+		mtk_dp_read(mtk_dp, 0x33c8) * mtk_dp->train_info.link_rate * 27 / 0x8000);
+	pr_notice("xinlei: %s exit", __func__);
 	return;
 power_off_aux:
 	mtk_dp_update_bits(mtk_dp, MTK_DP_TOP_PWR_STATE,
@@ -2367,6 +2428,11 @@ static void mtk_dp_bridge_atomic_disable(struct drm_bridge *bridge,
 					 struct drm_bridge_state *old_state)
 {
 	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
+	
+	if (mtk_dp_plug_state(mtk_dp)) {
+		drm_dp_dpcd_writeb(&mtk_dp->aux, DP_SET_POWER, DP_SET_POWER_D3);
+		usleep_range(2000, 3000);
+	}
 
 	mtk_dp->enabled = false;
 	mtk_dp_update_plugged_status(mtk_dp);
@@ -2405,11 +2471,10 @@ mtk_dp_bridge_mode_valid(struct drm_bridge *bridge,
 	return MODE_OK;
 }
 
-static u32 *mtk_dp_bridge_atomic_get_output_bus_fmts(struct drm_bridge *bridge,
-						     struct drm_bridge_state *bridge_state,
-						     struct drm_crtc_state *crtc_state,
-						     struct drm_connector_state *conn_state,
-						     unsigned int *num_output_fmts)
+static u32 *mtk_dp_bridge_atomic_get_output_bus_fmts(
+	struct drm_bridge *bridge, struct drm_bridge_state *bridge_state,
+	struct drm_crtc_state *crtc_state,
+	struct drm_connector_state *conn_state, unsigned int *num_output_fmts)
 {
 	u32 *output_fmts;
 
@@ -2428,12 +2493,11 @@ static const u32 mt8195_input_fmts[] = {
 	MEDIA_BUS_FMT_YUYV8_1X16,
 };
 
-static u32 *mtk_dp_bridge_atomic_get_input_bus_fmts(struct drm_bridge *bridge,
-						    struct drm_bridge_state *bridge_state,
-						    struct drm_crtc_state *crtc_state,
-						    struct drm_connector_state *conn_state,
-						    u32 output_fmt,
-						    unsigned int *num_input_fmts)
+static u32 *mtk_dp_bridge_atomic_get_input_bus_fmts(
+	struct drm_bridge *bridge, struct drm_bridge_state *bridge_state,
+	struct drm_crtc_state *crtc_state,
+	struct drm_connector_state *conn_state, u32 output_fmt,
+	unsigned int *num_input_fmts)
 {
 	u32 *input_fmts;
 	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
@@ -2485,7 +2549,7 @@ static int mtk_dp_bridge_atomic_check(struct drm_bridge *bridge,
 
 	input_bus_format = bridge_state->input_bus_cfg.format;
 
-	dev_dbg(mtk_dp->dev, "input format 0x%04x, output format 0x%04x\n",
+	dev_info(mtk_dp->dev, "input format 0x%04x, output format 0x%04x\n",
 		bridge_state->input_bus_cfg.format,
 		 bridge_state->output_bus_cfg.format);
 
@@ -2505,29 +2569,6 @@ static int mtk_dp_bridge_atomic_check(struct drm_bridge *bridge,
 	return 0;
 }
 
-static void mtk_dp_bridge_hpd_notify(struct drm_bridge *bridge,
-				     enum drm_connector_status status)
-{
-	struct mtk_dp *mtk_dp = mtk_dp_from_bridge(bridge);
-	struct mtk_dp_train_info *train_info = &mtk_dp->train_info;
-
-	if (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP) {
-		if (mtk_dp->hpd_state != status) {
-			if (status == connector_status_disconnected) {
-				train_info->cable_plugged_in = false;
-			} else {
-				mtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3414,
-					HPD_OVR_EN_DP_TRANS_P0_MASK,
-					HPD_OVR_EN_DP_TRANS_P0_MASK);
-				mtk_dp_update_bits(mtk_dp, MTK_DP_TRANS_P0_3414,
-					HPD_SET_DP_TRANS_P0_MASK,
-					HPD_SET_DP_TRANS_P0_MASK);
-				train_info->cable_plugged_in = true;
-			}
-			mtk_dp->hpd_state = status;
-		}
-	}
-}
 
 static const struct drm_bridge_funcs mtk_dp_bridge_funcs = {
 	.atomic_check = mtk_dp_bridge_atomic_check,
@@ -2543,7 +2584,6 @@ static const struct drm_bridge_funcs mtk_dp_bridge_funcs = {
 	.mode_valid = mtk_dp_bridge_mode_valid,
 	.get_edid = mtk_dp_get_edid,
 	.detect = mtk_dp_bdg_detect,
-	.hpd_notify = mtk_dp_bridge_hpd_notify,
 };
 
 static void mtk_dp_debounce_timer(struct timer_list *t)
@@ -2567,11 +2607,12 @@ static int mtk_dp_audio_hw_params(struct device *dev, void *data,
 		return -ENODEV;
 	}
 
-	mtk_dp->info.audio_cur_cfg.channels = params->cea.channels;
-	mtk_dp->info.audio_cur_cfg.sample_rate = params->sample_rate;
-
-	mtk_dp_audio_setup(mtk_dp, &mtk_dp->info.audio_cur_cfg);
+	cfg.channels = params->cea.channels;
+	cfg.sample_rate = params->sample_rate;
+	cfg.word_length_bits = 24;
 
+	mtk_dp_audio_setup(mtk_dp, &cfg);	
+	
 	return 0;
 }
 
@@ -2601,6 +2642,7 @@ static int mtk_dp_audio_get_eld(struct device *dev, void *data, uint8_t *buf,
 	else
 		memset(buf, 0, len);
 
+		dev_dbg(mtk_dp->dev, "get eld: %*ph\n", (int)len, buf);
 	return 0;
 }
 
@@ -2703,12 +2745,15 @@ static int mtk_dp_probe(struct platform_device *pdev)
 	struct mtk_dp *mtk_dp;
 	struct device *dev = &pdev->dev;
 	int ret;
+	struct drm_panel *panel = NULL;
 
+	pr_notice("xinlei: %s enter", __func__);
 	mtk_dp = devm_kzalloc(dev, sizeof(*mtk_dp), GFP_KERNEL);
 	if (!mtk_dp)
 		return -ENOMEM;
 
 	mtk_dp->dev = dev;
+
 	mtk_dp->data = (struct mtk_dp_data *)of_device_get_match_data(dev);
 
 	ret = mtk_dp_dt_parse(mtk_dp, pdev);
@@ -2819,6 +2864,7 @@ static int mtk_dp_probe(struct platform_device *pdev)
 	pm_runtime_enable(dev);
 	pm_runtime_get_sync(dev);
 
+	pr_notice("xinlei: %s exit", __func__);
 	return 0;
 }
 
@@ -2839,8 +2885,8 @@ static void mtk_dp_remove(struct platform_device *pdev)
 static int mtk_dp_suspend(struct device *dev)
 {
 	struct mtk_dp *mtk_dp = dev_get_drvdata(dev);
-
-	mtk_dp_power_disable(mtk_dp);
+	
+	mtk_dp_hwirq_enable(mtk_dp, false);
 	if (mtk_dp->bridge.type != DRM_MODE_CONNECTOR_eDP)
 		mtk_dp_hwirq_enable(mtk_dp, false);
 	pm_runtime_put_sync(dev);
@@ -2894,17 +2940,12 @@ static const struct of_device_id mtk_dp_of_match[] = {
 		.compatible = "mediatek,mt8188-edp-tx",
 		.data = &mt8195_edp_data,
 	},
-	{
-		.compatible = "mediatek,mt8188-dp-tx",
-		.data = &mt8188_dp_data,
-	},
 	{
 		.compatible = "mediatek,mt8195-edp-tx",
 		.data = &mt8195_edp_data,
 	},
 	{
 		.compatible = "mediatek,mt8195-dp-tx",
-		.data = &mt8195_dp_data,
 	},
 	{},
 };
-- 
2.49.0

