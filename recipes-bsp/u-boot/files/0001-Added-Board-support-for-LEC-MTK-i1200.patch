From d2823b5a46cf6f0e0f235667140655c48bad2178 Mon Sep 17 00:00:00 2001
From: "deepak.s" <deepak.s@adlinktech.com>
Date: Tue, 27 Aug 2024 11:32:05 +0530
Subject: [PATCH] Added Board support for LEC-MTK-i1200

---
 arch/arm/dts/Makefile                         |   1 +
 arch/arm/mach-mediatek/Kconfig                |   8 +-
 arch/arm/mach-mediatek/Makefile               |   1 +
 arch/arm/mach-mediatek/lec_mtk_i1200/Kconfig  |  13 +
 arch/arm/mach-mediatek/lec_mtk_i1200/Makefile |   3 +
 arch/arm/mach-mediatek/lec_mtk_i1200/init.c   |  99 ++++++
 board/mediatek/lec_mtk_i1200/MAINTAINERS      |   6 +
 board/mediatek/lec_mtk_i1200/Makefile         |   8 +
 board/mediatek/lec_mtk_i1200/lec_mtk_i1200.c  | 302 ++++++++++++++++++
 .../mediatek/lec_mtk_i1200/mt8195_evk_panel.c | 247 ++++++++++++++
 include/configs/lec_mtk_i1200.h               | 126 ++++++++
 11 files changed, 813 insertions(+), 1 deletion(-)
 create mode 100755 arch/arm/mach-mediatek/lec_mtk_i1200/Kconfig
 create mode 100755 arch/arm/mach-mediatek/lec_mtk_i1200/Makefile
 create mode 100755 arch/arm/mach-mediatek/lec_mtk_i1200/init.c
 create mode 100755 board/mediatek/lec_mtk_i1200/MAINTAINERS
 create mode 100755 board/mediatek/lec_mtk_i1200/Makefile
 create mode 100755 board/mediatek/lec_mtk_i1200/lec_mtk_i1200.c
 create mode 100755 board/mediatek/lec_mtk_i1200/mt8195_evk_panel.c
 create mode 100755 include/configs/lec_mtk_i1200.h

diff --git a/arch/arm/dts/Makefile b/arch/arm/dts/Makefile
index e10c5ace83..684be40a13 100644
--- a/arch/arm/dts/Makefile
+++ b/arch/arm/dts/Makefile
@@ -1235,6 +1235,7 @@ dtb-$(CONFIG_ARCH_MEDIATEK) += \
 	mt7629-rfb.dtb \
 	mt8183-pumpkin.dtb \
 	mt8195-demo.dtb \
+	lec-mtk-i1200-ufs.dtb \
 	mt8195-evb-ufs.dtb \
 	mt8365-pumpkin.dtb \
 	mt8512-bm1-emmc.dtb \
diff --git a/arch/arm/mach-mediatek/Kconfig b/arch/arm/mach-mediatek/Kconfig
index 72da07527d..3a1c5d3456 100644
--- a/arch/arm/mach-mediatek/Kconfig
+++ b/arch/arm/mach-mediatek/Kconfig
@@ -67,6 +67,10 @@ config TARGET_MT8195
 	  SD and MMC cards, UFS, PWM, I2C, I2S, S/PDIF, and several LPDDR3
 	  and LPDDR4 options.
 
+config TARGET_LEC_MTK_I1200
+        bool "Adlinktech lec-mtk-i1200 board"
+        select ARM64
+
 
 config TARGET_MT8365
 	bool "MediaTek MT8365 SoC"
@@ -123,6 +127,7 @@ config SYS_BOARD
 	default "mt8183" if TARGET_MT8183
 	default "mt8188" if TARGET_MT8188
 	default "mt8195" if TARGET_MT8195
+	default "lec_mtk_i1200" if TARGET_LEC_MTK_I1200
 	default "mt8365" if TARGET_MT8365
 	default "mt8370" if TARGET_MT8370
 	default "mt8512" if TARGET_MT8512
@@ -142,6 +147,7 @@ config SYS_CONFIG_NAME
 	default "mt8183" if TARGET_MT8183
 	default "mt8188" if TARGET_MT8188
 	default "mt8195" if TARGET_MT8195
+	default "lec_mtk_i1200" if TARGET_LEC_MTK_I1200
 	default "mt8365" if TARGET_MT8365
 	default "mt8370" if TARGET_MT8370
 	default "mt8512" if TARGET_MT8512
@@ -157,7 +163,7 @@ config MTK_BROM_HEADER_INFO
 	string
 	default "media=nor" if TARGET_MT8518 || TARGET_MT8512 || TARGET_MT7629 || TARGET_MT7622
 	default "media=emmc" if TARGET_MT8516 || TARGET_MT8365 || TARGET_MT8183 || TARGET_MT8195 \
-		|| TARGET_MT8188 || TARGET_MT8370
+		|| TARGET_MT8188 || TARGET_MT8370 || TARGET_LEC_MTK_I1200
 	default "lk=1" if TARGET_MT7623
 
 config SERIAL_ANDROID
diff --git a/arch/arm/mach-mediatek/Makefile b/arch/arm/mach-mediatek/Makefile
index 27f79fcbb7..6f037c636e 100644
--- a/arch/arm/mach-mediatek/Makefile
+++ b/arch/arm/mach-mediatek/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_TARGET_MT7629) += mt7629/
 obj-$(CONFIG_TARGET_MT8183) += mt8183/
 obj-$(CONFIG_TARGET_MT8188) += mt8188/
 obj-$(CONFIG_TARGET_MT8195) += mt8195/
+obj-$(CONFIG_TARGET_LEC_MTK_I1200) += lec_mtk_i1200/
 obj-$(CONFIG_TARGET_MT8365) += mt8365/
 obj-$(CONFIG_TARGET_MT8370) += mt8370/
 obj-$(CONFIG_TARGET_MT8516) += mt8516/
diff --git a/arch/arm/mach-mediatek/lec_mtk_i1200/Kconfig b/arch/arm/mach-mediatek/lec_mtk_i1200/Kconfig
new file mode 100755
index 0000000000..a34fa2cf2e
--- /dev/null
+++ b/arch/arm/mach-mediatek/lec_mtk_i1200/Kconfig
@@ -0,0 +1,13 @@
+if TARGET_MT8195
+
+config SYS_BOARD
+	default "mt8195"
+
+config SYS_CONFIG_NAME
+	default "mt8195"
+
+config MTK_BROM_HEADER_INFO
+	string
+	default "media=emmc"
+
+endif
diff --git a/arch/arm/mach-mediatek/lec_mtk_i1200/Makefile b/arch/arm/mach-mediatek/lec_mtk_i1200/Makefile
new file mode 100755
index 0000000000..886ab7e4eb
--- /dev/null
+++ b/arch/arm/mach-mediatek/lec_mtk_i1200/Makefile
@@ -0,0 +1,3 @@
+# SPDX-License-Identifier:	GPL-2.0
+
+obj-y += init.o
diff --git a/arch/arm/mach-mediatek/lec_mtk_i1200/init.c b/arch/arm/mach-mediatek/lec_mtk_i1200/init.c
new file mode 100755
index 0000000000..48c8f8a2a6
--- /dev/null
+++ b/arch/arm/mach-mediatek/lec_mtk_i1200/init.c
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 MediaTek Inc.
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Fabien Parent <fparent@baylibre.com>
+ */
+
+#include <clk.h>
+#include <common.h>
+#include <dm.h>
+#include <fdtdec.h>
+#include <ram.h>
+#include <asm/arch/misc.h>
+#include <asm/armv8/mmu.h>
+#include <asm/sections.h>
+#include <asm/system.h>
+#include <dm/uclass.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int dram_init(void)
+{
+	int ret;
+
+	ret = fdtdec_setup_memory_banksize();
+	if (ret)
+		return ret;
+
+	fdtdec_setup_mem_size_base();
+
+	/*
+	 * Limit gd->ram_top not exceeding SZ_4G.
+	 * Because some periphals like mmc requires DMA buffer
+	 * allocaed below SZ_4G.
+	 *
+	 * Note: SZ_1M is for adjusting gd->relocaddr,
+	 *       the reserved memory for u-boot itself.
+	 */
+	if (gd->ram_base + gd->ram_size >= SZ_4G)
+		gd->mon_len = (gd->ram_base + gd->ram_size + SZ_1M) - SZ_4G;
+
+	return 0;
+}
+
+int dram_init_banksize(void)
+{
+	gd->bd->bi_dram[0].start = gd->ram_base;
+	gd->bd->bi_dram[0].size = gd->ram_size;
+
+	return 0;
+}
+
+int mtk_pll_early_init(void)
+{
+	return 0;
+}
+
+int mtk_soc_early_init(void)
+{
+	return 0;
+}
+
+#ifndef CONFIG_SYSRESET
+void reset_cpu(ulong addr)
+{
+	psci_system_reset();
+}
+#endif
+
+int print_cpuinfo(void)
+{
+	u32 part = mediatek_sip_part_name();
+
+	if (part)
+		printf("CPU:   MediaTek MT%.4x\n", part);
+	else
+		printf("CPU:   MediaTek MT8195\n");
+	return 0;
+}
+
+static struct mm_region mt8195_mem_map[] = {
+	{
+		/* DDR */
+		.virt = 0x40000000UL,
+		.phys = 0x40000000UL,
+		.size = 0x80000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_NORMAL) | PTE_BLOCK_OUTER_SHARE,
+	}, {
+		.virt = 0x00000000UL,
+		.phys = 0x00000000UL,
+		.size = 0x20000000UL,
+		.attrs = PTE_BLOCK_MEMTYPE(MT_DEVICE_NGNRNE) |
+			 PTE_BLOCK_NON_SHARE |
+			 PTE_BLOCK_PXN | PTE_BLOCK_UXN
+	}, {
+		0,
+	}
+};
+struct mm_region *mem_map = mt8195_mem_map;
diff --git a/board/mediatek/lec_mtk_i1200/MAINTAINERS b/board/mediatek/lec_mtk_i1200/MAINTAINERS
new file mode 100755
index 0000000000..3cc03b507b
--- /dev/null
+++ b/board/mediatek/lec_mtk_i1200/MAINTAINERS
@@ -0,0 +1,6 @@
+MT8195 Pumpkin
+M:	Fabien Parent <fparent@baylibre.com>
+S:	Maintained
+F:	board/mediatek/mt8195
+F:	include/configs/mt8195.h
+F:	configs/mt8195_demo_defconfig
diff --git a/board/mediatek/lec_mtk_i1200/Makefile b/board/mediatek/lec_mtk_i1200/Makefile
new file mode 100755
index 0000000000..1006e7c938
--- /dev/null
+++ b/board/mediatek/lec_mtk_i1200/Makefile
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier:	GPL-2.0
+
+obj-y += lec_mtk_i1200.o
+
+ifeq ($(CONFIG_VIDEO_MEDIATEK),y)
+	obj-y += mt8195_evk_panel.o mt8195_evk_edp_panel.o
+	ccflags-y += -I$(srctree)/drivers/video/mediatek/
+endif
diff --git a/board/mediatek/lec_mtk_i1200/lec_mtk_i1200.c b/board/mediatek/lec_mtk_i1200/lec_mtk_i1200.c
new file mode 100755
index 0000000000..4958fb4f3f
--- /dev/null
+++ b/board/mediatek/lec_mtk_i1200/lec_mtk_i1200.c
@@ -0,0 +1,302 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2020 BayLibre SAS
+ * Author: Fabien Parent <fparent@baylibre.com>
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <efi_loader.h>
+#include <net.h>
+#include <asm/io.h>
+#include <linux/kernel.h>
+#include <linux/arm-smccc.h>
+
+#include <env.h>
+#include <errno.h>
+#include <init.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <linux/delay.h>
+#include <asm/global_data.h>
+#include <asm-generic/gpio.h>
+#include <spl.h>
+#include <power/pmic.h>
+#include <usb.h>
+#include <dwc3-uboot.h>
+#include <mmc.h>
+#include <i2c.h>
+
+#define MT8195_UPDATABLE_IMAGES	5
+
+#if CONFIG_IS_ENABLED(EFI_HAVE_CAPSULE_SUPPORT)
+static struct efi_fw_image fw_images[MT8195_UPDATABLE_IMAGES] = {0};
+
+struct efi_capsule_update_info update_info = {
+	.dfu_string = "mmc 0=bl2.img raw 0x0 0x400000 mmcpart 1;"
+			"fip.bin part 0 1;firmware.vfat part 0 3;u-boot-env.bin raw 0x0 0x400000 mmcpart 2",
+	.images = fw_images,
+};
+
+u8 num_image_type_guids = MT8195_UPDATABLE_IMAGES;
+#endif
+
+#if defined(CONFIG_EFI_HAVE_CAPSULE_SUPPORT) && defined(CONFIG_EFI_PARTITION)
+enum mt8195_updatable_images {
+	MT8195_BL2_IMAGE = 1,
+	MT8195_FIP_IMAGE,
+	MT8195_FW_IMAGE,
+	MT8195_ENV_IMAGE,
+	MT8195_FIT_IMAGE,
+};
+
+static bool board_is_mt8195_demo(void)
+{
+	return CONFIG_IS_ENABLED(TARGET_MT8195) &&
+		of_machine_is_compatible("mediatek,mt8195-demo");
+}
+
+static bool board_is_genio_1200_evk(void)
+{
+	return CONFIG_IS_ENABLED(TARGET_MT8195) &&
+		of_machine_is_compatible("mediatek,genio-1200-evk");
+}
+
+static bool board_is_genio_1200_evk_ufs(void)
+{
+	return CONFIG_IS_ENABLED(TARGET_MT8195) &&
+		of_machine_is_compatible("mediatek,genio-1200-evk-ufs");
+}
+
+void mediatek_capsule_update_board_setup(void)
+{
+	fw_images[0].image_index = MT8195_FIT_IMAGE;
+	fw_images[1].image_index = MT8195_FIP_IMAGE;
+	fw_images[2].image_index = MT8195_BL2_IMAGE;
+	fw_images[3].image_index = MT8195_FW_IMAGE;
+	fw_images[4].image_index = MT8195_ENV_IMAGE;
+
+	if (board_is_mt8195_demo()) {
+		efi_guid_t image_type_guid = MT8195_DEMO_FIT_IMAGE_GUID;
+		efi_guid_t uboot_image_type_guid = MT8195_DEMO_FIP_IMAGE_GUID;
+		efi_guid_t bl2_image_type_guid = MT8195_DEMO_BL2_IMAGE_GUID;
+		efi_guid_t fw_image_type_guid = MT8195_DEMO_FW_IMAGE_GUID;
+		efi_guid_t env_image_type_guid = MT8195_DEMO_ENV_IMAGE_GUID;
+
+		guidcpy(&fw_images[0].image_type_id, &image_type_guid);
+		guidcpy(&fw_images[1].image_type_id, &uboot_image_type_guid);
+		guidcpy(&fw_images[2].image_type_id, &bl2_image_type_guid);
+		guidcpy(&fw_images[3].image_type_id, &fw_image_type_guid);
+		guidcpy(&fw_images[4].image_type_id, &env_image_type_guid);
+
+		fw_images[0].fw_name = u"MT8195-DEMO-FIT";
+		fw_images[1].fw_name = u"MT8195-DEMO-FIP";
+		fw_images[2].fw_name = u"MT8195-DEMO-BL2";
+		fw_images[3].fw_name = u"MT8195-DEMO-FW";
+		fw_images[4].fw_name = u"MT8195-DEMO-ENV";
+	} else if (board_is_genio_1200_evk()) {
+		efi_guid_t image_type_guid = GENIO_1200_EVK_FIT_IMAGE_GUID;
+		efi_guid_t uboot_image_type_guid = GENIO_1200_EVK_FIP_IMAGE_GUID;
+		efi_guid_t bl2_image_type_guid = GENIO_1200_EVK_BL2_IMAGE_GUID;
+		efi_guid_t fw_image_type_guid = GENIO_1200_EVK_FW_IMAGE_GUID;
+		efi_guid_t env_image_type_guid = GENIO_1200_EVK_ENV_IMAGE_GUID;
+
+		guidcpy(&fw_images[0].image_type_id, &image_type_guid);
+		guidcpy(&fw_images[1].image_type_id, &uboot_image_type_guid);
+		guidcpy(&fw_images[2].image_type_id, &bl2_image_type_guid);
+		guidcpy(&fw_images[3].image_type_id, &fw_image_type_guid);
+		guidcpy(&fw_images[4].image_type_id, &env_image_type_guid);
+
+		fw_images[0].fw_name = u"GENIO-1200-EVK-FIT";
+		fw_images[1].fw_name = u"GENIO-1200-EVK-FIP";
+		fw_images[2].fw_name = u"GENIO-1200-EVK-BL2";
+		fw_images[3].fw_name = u"GENIO-1200-EVK-FW";
+		fw_images[4].fw_name = u"GENIO-1200-EVK-ENV";
+	} else if (board_is_genio_1200_evk_ufs()) {
+		efi_guid_t image_type_guid = GENIO_1200_EVK_UFS_FIT_IMAGE_GUID;
+		efi_guid_t uboot_image_type_guid = GENIO_1200_EVK_UFS_FIP_IMAGE_GUID;
+		efi_guid_t bl2_image_type_guid = GENIO_1200_EVK_UFS_BL2_IMAGE_GUID;
+		efi_guid_t fw_image_type_guid = GENIO_1200_EVK_UFS_FW_IMAGE_GUID;
+		efi_guid_t env_image_type_guid = GENIO_1200_EVK_UFS_ENV_IMAGE_GUID;
+
+		guidcpy(&fw_images[0].image_type_id, &image_type_guid);
+		guidcpy(&fw_images[1].image_type_id, &uboot_image_type_guid);
+		guidcpy(&fw_images[2].image_type_id, &bl2_image_type_guid);
+		guidcpy(&fw_images[3].image_type_id, &fw_image_type_guid);
+		guidcpy(&fw_images[4].image_type_id, &env_image_type_guid);
+
+		fw_images[0].fw_name = u"GENIO-1200-EVK-UFS-FIT";
+		fw_images[1].fw_name = u"GENIO-1200-EVK-UFS-FIP";
+		fw_images[2].fw_name = u"GENIO-1200-EVK-UFS-BL2";
+		fw_images[3].fw_name = u"GENIO-1200-EVK-UFS-FW";
+		fw_images[4].fw_name = u"GENIO-1200-EVK-UFS-ENV";
+	}
+}
+#endif /* CONFIG_EFI_HAVE_CAPSULE_SUPPORT && CONFIG_EFI_PARTITION */
+
+int board_init(void)
+{
+	struct udevice *dev;
+	int ret;
+
+	if (CONFIG_IS_ENABLED(USB_GADGET)) {
+		ret = uclass_get_device(UCLASS_USB_GADGET_GENERIC, 0, &dev);
+		if (ret) {
+			pr_err("%s: Cannot find USB device\n", __func__);
+			return ret;
+		}
+	}
+
+	if (CONFIG_IS_ENABLED(USB_ETHER))
+		usb_ether_init();
+
+	printf("Disabling WDT\n");
+	writel(0, 0x10007000);
+
+	printf("Enabling SCP SRAM\n");
+	for (unsigned int val = 0xFFFFFFFF; val != 0U;) {
+		val = val >> 1;
+		writel(val, 0x1072102C);
+	}
+
+        if (IS_ENABLED(CONFIG_EFI_HAVE_CAPSULE_SUPPORT) &&
+		    IS_ENABLED(CONFIG_EFI_PARTITION))
+	mediatek_capsule_update_board_setup();
+
+	return 0;
+}
+
+#define SKU_REG 0x10005220
+
+#define SKU_BIT0 0
+#define SKU_BIT1 1
+#define SKU_BIT2 2
+#define SKU_BIT3 3
+#define SKU_BIT4 4
+
+struct sku_info {
+    uint32_t sku_id;
+    char* sku_str;
+	const char* dtbo_file;
+};
+
+struct sku_info skus[] = {
+    {0, "LEC-MTK-I1200-2G-64G-CT(000E)", "conf-memory-2G.dtbo"},
+    {1, "LEC-MTK-I1200-4G-64G-CT(100E)", "conf-memory-4G.dtbo"},
+    {2, "LEC-MTK-I1200-8G-64G-CT(200E)", "conf-memory-8G.dtbo"},
+    {3, "LEC-MTK-I1200-2G-64G-BW-CT(300E)", "conf-memory-2G.dtbo"},
+    {4, "LEC-MTK-I1200-4G-64G-BW-CT(400E)", "conf-memory-4G.dtbo"},
+    {5, "LEC-MTK-I1200-8G-64G-BW-CT(500E)", "conf-memory-8G.dtbo"},
+    {6, "LEC-MTK-I1200-4G-64G-BW-ER(600E)", "conf-memory-4G.dtbo"},
+    {7, "LEC-MTK-I1200-8G-64G-BW-ER(700E)", "conf-memory-8G.dtbo"},
+    {8, "LEC-MTK-I1200-8G-128G-BW-ER(800E)", "conf-memory-8G.dtbo"}
+};
+
+#define PCB_REG			0x10005230
+#define PCB_BIT0 20
+#define PCB_BIT1 21
+
+#define PCB_PUPD_REG 	0x11F40030
+#define PCB_PUPD_BIT0	9
+#define PCB_PUPD_BIT1	8
+#define SX150		0x3f
+static struct gpio_desc board_detect_desc[5];
+
+static void board_usbgpio_init(void)
+{
+
+        int node;
+        int ret;
+	/*USB_P0_P2_MUX_SEL*/
+
+        node = fdt_node_offset_by_compatible(gd->fdt_blob, 0,
+                "solidrun,hummingboard-detect");
+        if (node < 0){
+                printf("%s: Can't lookup gpio name \n", __func__);
+                return -ENODEV;
+	}
+
+        ret = gpio_request_list_by_name_nodev(offset_to_ofnode(node),
+                "detect-gpios", board_detect_desc,
+                ARRAY_SIZE(board_detect_desc), GPIOD_IS_OUT);
+
+        if (ret < 0){
+                printf("%s: Can't lookup gpio  \n", __func__);
+                return -ENODEV;
+	}
+
+}
+
+static void setup_dsi(void)
+{
+	        char dsisetup[255];
+		sprintf(dsisetup,"i2c dev 4 ; i2c mw 0x3f 0x0f 0xfe 1; i2c mw 0x3f 0x11 0x3a 1");
+   		run_command(dsisetup, 0);
+}
+
+int board_late_init(void)
+{
+	char *boot_conf_orig = env_get("boot_conf");
+	char cmd[128];
+
+    uint32_t sku_id_0 = (*(volatile uint32_t *)SKU_REG >> SKU_BIT0) & 0x1;
+    uint32_t sku_id_1 = (*(volatile uint32_t *)SKU_REG >> SKU_BIT1) & 0x1;
+    uint32_t sku_id_2 = (*(volatile uint32_t *)SKU_REG >> SKU_BIT2) & 0x1;
+    uint32_t sku_id_3 = (*(volatile uint32_t *)SKU_REG >> SKU_BIT3) & 0x1;
+    uint32_t sku_id_4 = (*(volatile uint32_t *)SKU_REG >> SKU_BIT4) & 0x1;
+
+    uint32_t sku_id = (sku_id_4 << 4) | (sku_id_3 << 3) | (sku_id_2 << 2) | (sku_id_1 << 1) | sku_id_0;
+
+    int i;
+    for (i = 0; i < sizeof(skus)/sizeof(struct sku_info); i++) {
+        if (skus[i].sku_id == sku_id) {
+            printf("SKU:   %s\n", skus[i].sku_str);
+			snprintf(cmd, sizeof(cmd), "setenv boot_conf '%s#%s'", boot_conf_orig, skus[i].dtbo_file);
+			run_command(cmd, 0);
+            break;
+        }
+    }
+
+    if (i == sizeof(skus)/sizeof(struct sku_info)) {
+        printf("Unknown SKU\n");
+    }
+
+    uint32_t reg_value;
+
+    /* Read the original value of the register */
+    reg_value = readl(PCB_PUPD_REG);
+
+    /* Clear bits at positions BIT0 and BIT1 */
+    reg_value &= ~(1 << PCB_PUPD_BIT0);
+    reg_value &= ~(1 << PCB_PUPD_BIT1);
+
+    /* Write back the new value to the register */
+    writel(reg_value, PCB_PUPD_REG);
+
+    uint32_t pcb_id_0 = (*(volatile uint32_t *)PCB_REG >> PCB_BIT0) & 0x1;
+    uint32_t pcb_id_1 = (*(volatile uint32_t *)PCB_REG >> PCB_BIT1) & 0x1;
+
+    uint32_t pcb_id = (pcb_id_1 << 1) | pcb_id_0;
+
+    switch (pcb_id) {
+    case 0:
+        printf("PCB:   PCB A1\n");
+        break;
+    case 1:
+        printf("PCB:   PCB A2\n");
+        break;
+    case 2:
+        printf("PCB:   PCB A3\n");
+        break;
+    case 3:
+        printf("PCB:   PCB A4\n");
+        break;
+    default:
+        printf("Unknown PCB\n");
+        break;
+    }
+	
+    board_usbgpio_init();
+    setup_dsi();
+    return 0;
+}
diff --git a/board/mediatek/lec_mtk_i1200/mt8195_evk_panel.c b/board/mediatek/lec_mtk_i1200/mt8195_evk_panel.c
new file mode 100755
index 0000000000..cbd6bd2c82
--- /dev/null
+++ b/board/mediatek/lec_mtk_i1200/mt8195_evk_panel.c
@@ -0,0 +1,247 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * MediaTek kd070fhfid078_dsi driver
+ *
+ * Copyright (c) 2023 MediaTek Inc.
+ * Author: Tommy Chen <tommyyl.chen@mediatek.com>
+ */
+
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <asm/gpio.h>
+#include "mtk_panel.h"
+
+void panel_get_desc(struct panel_description **panel_desc);
+
+struct dsi_info kd070fhfid078_dsi = {
+	.lanes = 4,
+	.flag = (MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM),
+	.format = MIPI_DSI_FMT_RGB888,
+};
+
+struct panel_serializable_data STARTEK_KD070FHFID078 = {
+	.vm = {
+		.pixelclock = 157126,/* pixelclock in KHz */
+		.pll_clk = 502,
+		.hactive = 1920,
+		.hfront_porch = 77,
+		.hback_porch = 117,
+		.hsync_len = 56,
+		.vactive = 1200,
+		.vfront_porch = 11,
+		.vback_porch = 19,
+		.vsync_len = 16,
+		.vrefresh = 60,
+	},
+	.init_cmd = {
+		INIT_GENERIC_CMD(0x00, 0x00),
+		INIT_GENERIC_CMD(0x01, 0xff),
+		INIT_GENERIC_CMD(0x02, 0xff),
+		INIT_GENERIC_CMD(0x03, 0xff),
+		INIT_GENERIC_CMD(0x04, 0xff),
+		INIT_GENERIC_CMD(0x05, 0xff),
+		INIT_GENERIC_CMD(0x06, 0xff),
+		INIT_GENERIC_CMD(0x07, 0x00),
+		INIT_GENERIC_CMD(0x08, 0x06),
+		INIT_GENERIC_CMD(0x09, 0xaf),
+		INIT_GENERIC_CMD(0x0a, 0xd8),
+		INIT_GENERIC_CMD(0x0b, 0x17),
+		INIT_GENERIC_CMD(0x0c, 0x00),
+		INIT_GENERIC_CMD(0x0d, 0x00),
+		INIT_GENERIC_CMD(0x0e, 0x00),
+		INIT_GENERIC_CMD(0x0f, 0x00),
+		INIT_GENERIC_CMD(0x10, 0x16),
+		INIT_GENERIC_CMD(0x11, 0x17),
+		INIT_GENERIC_CMD(0x12, 0x01),
+		INIT_GENERIC_CMD(0x13, 0x04),
+		INIT_GENERIC_CMD(0x14, 0xa0),
+		INIT_GENERIC_CMD(0x15, 0x16),
+		INIT_GENERIC_CMD(0x16, 0x0e),
+		INIT_GENERIC_CMD(0x17, 0x78),
+		INIT_GENERIC_CMD(0x18, 0x02),
+		INIT_GENERIC_CMD(0x19, 0xd3),
+		INIT_GENERIC_CMD(0x1a, 0xa5),
+		INIT_GENERIC_CMD(0x1b, 0x97),
+		INIT_GENERIC_CMD(0x1c, 0x57),
+		INIT_GENERIC_CMD(0x1d, 0x53),
+		INIT_GENERIC_CMD(0x1e, 0x96),
+		INIT_GENERIC_CMD(0x1f, 0x27),
+		INIT_GENERIC_CMD(0x20, 0x1f),
+		INIT_GENERIC_CMD(0x21, 0x50),
+		INIT_GENERIC_CMD(0x22, 0x54),
+		INIT_GENERIC_CMD(0x23, 0x00),
+		INIT_GENERIC_CMD(0x24, 0x00),
+		INIT_GENERIC_CMD(0x25, 0x00),
+		INIT_GENERIC_CMD(0x26, 0x01),
+		INIT_GENERIC_CMD(0x27, 0x01),
+		INIT_GENERIC_CMD(0x28, 0x01),
+		INIT_GENERIC_CMD(0x29, 0x01),
+		INIT_GENERIC_CMD(0x2a, 0x01),
+		INIT_GENERIC_CMD(0x2b, 0x01),
+		INIT_GENERIC_CMD(0x2c, 0x01),
+		INIT_GENERIC_CMD(0x2d, 0x01),
+		INIT_GENERIC_CMD(0x2e, 0x01),
+		INIT_GENERIC_CMD(0x2f, 0x01),
+		INIT_GENERIC_CMD(0x30, 0x01),
+		INIT_GENERIC_CMD(0x31, 0x01),
+		INIT_GENERIC_CMD(0x32, 0x01),
+		INIT_GENERIC_CMD(0x33, 0x01),
+		INIT_GENERIC_CMD(0x34, 0x01),
+		INIT_GENERIC_CMD(0x35, 0x01),
+		INIT_GENERIC_CMD(0x36, 0xf3),
+		INIT_GENERIC_CMD(0x37, 0x39),
+		INIT_GENERIC_CMD(0x38, 0x80),
+		INIT_GENERIC_CMD(0x39, 0x78),
+		INIT_GENERIC_CMD(0x3a, 0x70),
+		INIT_GENERIC_CMD(0x3b, 0xb0),
+		INIT_GENERIC_CMD(0x3c, 0x0c),
+		INIT_GENERIC_CMD(0x3d, 0x40),
+		INIT_GENERIC_CMD(0x3e, 0x28),
+		INIT_GENERIC_CMD(0x3f, 0x28),
+		INIT_GENERIC_CMD(0x40, 0x44),
+		INIT_GENERIC_CMD(0x41, 0x00),
+		INIT_GENERIC_CMD(0x42, 0xd8),
+		INIT_GENERIC_CMD(0x43, 0x87),
+		INIT_GENERIC_CMD(0x44, 0x00),
+		INIT_GENERIC_CMD(0x45, 0x00),
+		INIT_GENERIC_CMD(0x46, 0x00),
+		INIT_GENERIC_CMD(0x47, 0x18),
+		INIT_GENERIC_CMD(0x48, 0x00),
+		INIT_GENERIC_CMD(0x49, 0x00),
+		INIT_GENERIC_CMD(0x4a, 0x00),
+		INIT_GENERIC_CMD(0x4b, 0x0f),
+		INIT_GENERIC_CMD(0x4c, 0x00),
+		INIT_GENERIC_CMD(0x4d, 0x00),
+		INIT_GENERIC_CMD(0x4e, 0x00),
+		INIT_GENERIC_CMD(0x4f, 0x00),
+                INIT_GENERIC_CMD(0x51, 0x09),
+                INIT_GENERIC_CMD(0x52, 0x0B),
+                INIT_GENERIC_CMD(0x56, 0x0B),
+                INIT_GENERIC_CMD(0x54, 0x00),
+                INIT_GENERIC_CMD(0x55, 0x00),
+                INIT_GENERIC_CMD(0x56, 0x0E),
+                INIT_GENERIC_CMD(0x57, 0x0E),
+                INIT_GENERIC_CMD(0x58, 0x07),
+                INIT_GENERIC_CMD(0x59, 0x07),
+                INIT_GENERIC_CMD(0x5a, 0x06),
+                INIT_GENERIC_CMD(0x5b, 0x06),
+                INIT_GENERIC_CMD(0x5c, 0x00),
+                INIT_GENERIC_CMD(0x5d, 0xfe),
+                INIT_GENERIC_CMD(0x5e, 0x06),
+                INIT_GENERIC_CMD(0x5f, 0x41),
+                INIT_GENERIC_CMD(0x60, 0x55),
+                INIT_GENERIC_CMD(0x61, 0x4f),
+                INIT_GENERIC_CMD(0x62, 0x0a),
+                INIT_GENERIC_CMD(0x63, 0x20),
+                INIT_GENERIC_CMD(0x64, 0x20),
+                INIT_GENERIC_CMD(0x65, 0x20),
+                INIT_GENERIC_CMD(0x66, 0x20),
+                INIT_GENERIC_CMD(0x67, 0x20),
+                INIT_GENERIC_CMD(0x68, 0x20),
+                INIT_GENERIC_CMD(0x69, 0x20),
+                INIT_GENERIC_CMD(0x6a, 0x20),
+                INIT_GENERIC_CMD(0x6b, 0x20),
+                INIT_GENERIC_CMD(0x6c, 0x00),
+                INIT_GENERIC_CMD(0x6d, 0x00),
+                INIT_GENERIC_CMD(0x6e, 0x00),
+                INIT_GENERIC_CMD(0x6f, 0xfe),
+                INIT_GENERIC_CMD(0x70, 0x00),
+                INIT_GENERIC_CMD(0x71, 0x42),
+                INIT_GENERIC_CMD(0x72, 0x31),
+                INIT_GENERIC_CMD(0x73, 0x30),
+                INIT_GENERIC_CMD(0x74, 0x31),
+                INIT_GENERIC_CMD(0x75, 0x55),
+                INIT_GENERIC_CMD(0x76, 0x41),
+                INIT_GENERIC_CMD(0x77, 0x4e),
+                INIT_GENERIC_CMD(0x78, 0x30),
+                INIT_GENERIC_CMD(0x79, 0x31),
+                INIT_GENERIC_CMD(0x7a, 0x2e),
+                INIT_GENERIC_CMD(0x7b, 0x37),
+                INIT_GENERIC_CMD(0x7c, 0x20),
+                INIT_GENERIC_CMD(0x7d, 0x0a),
+                INIT_GENERIC_CMD(0x7e, 0x00),
+                INIT_GENERIC_CMD(0x7f, 0x2c),
+
+		INIT_DCS_CMD(0x11),
+		INIT_DELAY_CMD(120),
+		INIT_DCS_CMD(0x29),
+		INIT_DELAY_CMD(20),
+		INIT_END_CMD,
+	},
+	.dsi = &kd070fhfid078_dsi,
+};
+
+static void startek_kd070fhfid078_power_on(void)
+{
+	struct panel_description *panel_desc = NULL;
+
+	panel_get_desc(&panel_desc);
+
+	if (dm_gpio_is_valid(&panel_desc->reset_gpio) &&
+	    dm_gpio_is_valid(&panel_desc->dcdc_en_gpio) &&
+	    dm_gpio_is_valid(&panel_desc->enable_gpio)) 
+		
+	{
+		dm_gpio_set_value(&panel_desc->enable_gpio, 0);
+
+		dm_gpio_set_value(&panel_desc->dcdc_en_gpio, 0);
+		mdelay(1);
+
+		dm_gpio_set_value(&panel_desc->reset_gpio, 0);
+		mdelay(1);
+
+		dm_gpio_set_value(&panel_desc->enable_gpio, 1);
+		mdelay(10);
+
+		dm_gpio_set_value(&panel_desc->dcdc_en_gpio, 1);
+		mdelay(20);
+
+		dm_gpio_set_value(&panel_desc->reset_gpio, 1);
+		mdelay(5);
+
+//		dm_gpio_set_value(&panel_desc->reset_gpio, 0);
+//		mdelay(10);
+
+//		dm_gpio_set_value(&panel_desc->reset_gpio, 1);
+//		mdelay(5);
+	} else {
+		printf("Warning: %s some gpios invalid. could not power on panel\n", __func__);
+	}
+}
+
+static void startek_kd070fhfid078_power_off(void)
+{
+	struct panel_description *panel_desc = NULL;
+
+	panel_get_desc(&panel_desc);
+
+	if (dm_gpio_is_valid(&panel_desc->enable_gpio))
+		dm_gpio_set_value(&panel_desc->enable_gpio, 0);
+	if (dm_gpio_is_valid(&panel_desc->reset_gpio)) {
+		dm_gpio_set_value(&panel_desc->reset_gpio, 0);
+		mdelay(15);
+	}
+	if (dm_gpio_is_valid(&panel_desc->dcdc_en_gpio)) {
+		dm_gpio_set_value(&panel_desc->dcdc_en_gpio, 0);
+		mdelay(3);
+	}
+}
+
+static void enable_backlight(void)
+{
+	lcm_if_set_backlight(10, 16, false);
+}
+
+struct panel_description startek_kd070fhfid078_desc = {
+	.name = "startek_kd070fhfid078",
+	.compatible = "startek,kd070fhfid078",
+	.s = &STARTEK_KD070FHFID078,
+	.power_on = startek_kd070fhfid078_power_on,
+	.power_off = startek_kd070fhfid078_power_off,
+	.backlight_enable = enable_backlight,
+};
+
+void panel_get_desc(struct panel_description **panel_desc)
+{
+	*panel_desc = &startek_kd070fhfid078_desc;
+}
diff --git a/include/configs/lec_mtk_i1200.h b/include/configs/lec_mtk_i1200.h
new file mode 100755
index 0000000000..64f7a19364
--- /dev/null
+++ b/include/configs/lec_mtk_i1200.h
@@ -0,0 +1,126 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Configuration for MT8195 based boards
+ *
+ * Copyright (C) 2021 BayLibre, SAS
+ * Author: Fabien Parent <fparent@baylibre.com
+ */
+
+#ifndef __LEC_MTK_I1200_H
+#define __LEC_MTK_I1200_H
+
+#include <linux/sizes.h>
+
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	-4
+#define CONFIG_SYS_NS16550_MEM32
+#define CONFIG_SYS_NS16550_COM1		0x11002000
+#define CONFIG_SYS_NS16550_CLK		26000000
+
+#define MT8195_DEMO_FIT_IMAGE_GUID \
+	EFI_GUID(0x0538fd5d, 0x00dc, 0x47c5, 0x8d, 0x26, \
+		 0x43, 0x48, 0x03, 0xb1, 0xe3, 0x27)
+
+#define MT8195_DEMO_FIP_IMAGE_GUID \
+	EFI_GUID(0xf65ec70e, 0x45ab, 0x40fb, 0x99, 0x52, \
+		 0xe5, 0xbc, 0x30, 0x70, 0xda, 0x5c)
+
+#define MT8195_DEMO_BL2_IMAGE_GUID \
+	EFI_GUID(0xac11d376, 0xfdd4, 0x419f, 0x88, 0x97, \
+		 0x84, 0x93, 0xdd, 0x1b, 0x64, 0x60)
+
+#define MT8195_DEMO_FW_IMAGE_GUID \
+	EFI_GUID(0xea438b6b, 0x6f42, 0x422f, 0xb2, 0x39, \
+		 0xa3, 0xfb, 0xaf, 0x0f, 0x76, 0xd5)
+
+#define MT8195_DEMO_ENV_IMAGE_GUID \
+	EFI_GUID(0xdd73443e, 0x4ab8, 0x4f96, 0xbf, 0x82, \
+		 0xd3, 0x24, 0xff, 0x34, 0x6e, 0xff)
+
+#define GENIO_1200_EVK_FIT_IMAGE_GUID \
+	EFI_GUID(0x9fd30648, 0xb128, 0x440d, 0xbd, 0xd9, \
+		 0x0e, 0x53, 0xeb, 0x2a, 0x3c, 0xb8)
+
+#define GENIO_1200_EVK_FIP_IMAGE_GUID \
+	EFI_GUID(0x39961e72, 0x5a8e, 0x445a, 0x90, 0xfe, \
+		 0xed, 0x68, 0x33, 0x07, 0x44, 0xec)
+
+#define GENIO_1200_EVK_BL2_IMAGE_GUID \
+	EFI_GUID(0xa4a60c91, 0xffa3, 0x4cb8, 0x9b, 0x2a, \
+		 0x4f, 0xf8, 0x13, 0x62, 0x0d, 0x22)
+
+#define GENIO_1200_EVK_FW_IMAGE_GUID \
+	EFI_GUID(0xe9fe6bbd, 0x30ba, 0x4c90, 0x82, 0xe2, \
+		 0x2c, 0x3e, 0xa7, 0xed, 0xdd, 0x3d)
+
+#define GENIO_1200_EVK_ENV_IMAGE_GUID \
+	EFI_GUID(0x85ef9f43, 0xd9c9, 0x4817, 0xb5, 0x5e, \
+		 0x3b, 0x31, 0x68, 0x9e, 0x0e, 0x7a)
+
+#define GENIO_1200_EVK_UFS_FIT_IMAGE_GUID \
+	EFI_GUID(0x49be7238, 0x9c9f, 0x4e4f, 0x94, 0x45, \
+		 0x38, 0x9f, 0xcf, 0xd2, 0xa5, 0x12)
+
+#define GENIO_1200_EVK_UFS_FIP_IMAGE_GUID \
+	EFI_GUID(0x0c1603a7, 0x7f3d, 0x427c, 0x9e, 0xcc, \
+		 0xf9, 0xb0, 0x2d, 0x2f, 0xc7, 0x29)
+
+#define GENIO_1200_EVK_UFS_BL2_IMAGE_GUID \
+	EFI_GUID(0xdcae4ff5, 0x53f2, 0x4664, 0xb0, 0x59, \
+		 0x83, 0xeb, 0x33, 0xab, 0xf0, 0x6d)
+
+#define GENIO_1200_EVK_UFS_FW_IMAGE_GUID \
+	EFI_GUID(0xc6c7ba82, 0xe4ac, 0x49ce, 0xa7, 0x1f, \
+		 0x10, 0xe1, 0x44, 0x74, 0xa7, 0x07)
+
+#define GENIO_1200_EVK_UFS_ENV_IMAGE_GUID \
+	EFI_GUID(0xc3bef54b, 0x80eb, 0x4ee4, 0xbf, 0xd1, \
+		 0xb3, 0xfd, 0xc5, 0x50, 0x82, 0x66)
+/* Environment settings */
+#include <config_distro_bootcmd.h>
+
+#ifdef CONFIG_CMD_MMC
+#define BOOT_TARGET_MMC(func) func(MMC, mmc, 0)
+#else
+#define BOOT_TARGET_MMC(func)
+#endif
+
+#ifdef CONFIG_CMD_USB
+#define BOOT_TARGET_USB(func) func(USB, usb, 0)
+#else
+#define BOOT_TARGET_USB(func)
+#endif
+
+#ifdef CONFIG_CMD_SCSI
+#define BOOT_TARGET_SCSI(func) func(SCSI, scsi, 2)
+#else
+#define BOOT_TARGET_SCSI(func)
+#endif
+
+#define BOOT_TARGET_DEVICES(func) \
+	BOOT_TARGET_MMC(func) \
+	BOOT_TARGET_USB(func) \
+	BOOT_TARGET_SCSI(func)
+
+#if !defined(CONFIG_EXTRA_ENV_SETTINGS)
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"scriptaddr=0x40000000\0" \
+	"fdt_addr_r=0x44000000\0" \
+	"fdtoverlay_addr_r=0x44c00000\0" \
+	"kernel_addr_r=0x45000000\0" \
+	"ramdisk_addr_r=0x46000000\0" \
+	"bootargs=net.ifnames=0\0" \
+	"fdtfile=" CONFIG_DEFAULT_DEVICE_TREE ".dtb\0" \
+	"splashimage=" __stringify(CONFIG_SYS_LOAD_ADDR) "\0" \
+	"splashsource=scsi_fs\0" \
+	"splashfile=logo.bmp\0" \
+	"splashdevpart=2#bootassets\0" \
+	"splashpos=m,m\0" \
+	BOOTENV
+#endif
+
+#ifdef CONFIG_ARM64
+#define MTK_SIP_PARTNAME_ID		0xC2000529
+#endif
+
+#endif
-- 
2.45.2

