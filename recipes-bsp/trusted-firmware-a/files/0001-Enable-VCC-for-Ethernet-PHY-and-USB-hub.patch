From 2e21b416776abc6ef30fca954ad52de5e4f2eb25 Mon Sep 17 00:00:00 2001
From: aravindlal <aravindlal.mh@adlinktech.com>
Date: Wed, 9 Jul 2025 15:48:21 +0530
Subject: [PATCH]  Enable VCC for Ethernet PHY and USB hub

---
 .../drivers/pmic/pmic_initial_setting.c       |  3 +-
 .../mt8195/drivers/pmic/pmic_wrap_init.c      | 30 +++++++++++++++++++
 2 files changed, 32 insertions(+), 1 deletion(-)

diff --git a/plat/mediatek/mt8195/drivers/pmic/pmic_initial_setting.c b/plat/mediatek/mt8195/drivers/pmic/pmic_initial_setting.c
index 975963951..52acc10d8 100644
--- a/plat/mediatek/mt8195/drivers/pmic/pmic_initial_setting.c
+++ b/plat/mediatek/mt8195/drivers/pmic/pmic_initial_setting.c
@@ -254,7 +254,8 @@ void pmic_initial_setting(void)
 	mt6360_ldo_config_interface(0x1B, 0xD, 0xD, 0x4);
 	mt6360_ldo_config_interface(0x17, 0x3, 0x3, 0x6);
 
-	/* mt6360 ldo2, for DSI0 panel 1.8v on */
+        /* mt6360 ldo2, for DSI0 panel 1.8v on */ // --> update to 2.5v 
+        mt6360_ldo_config_interface(0x15, 0x7, 0x7, 0x4);	
 	mt6360_ldo_config_interface(0x11, 0x3, 0x3, 0x6);
 
 	/* mt6360 ldo3 3V on, mt6360 ldo5 3V on, for turn on MMC1 power */
diff --git a/plat/mediatek/mt8195/drivers/pmic/pmic_wrap_init.c b/plat/mediatek/mt8195/drivers/pmic/pmic_wrap_init.c
index 4ffe687eb..b831466c6 100644
--- a/plat/mediatek/mt8195/drivers/pmic/pmic_wrap_init.c
+++ b/plat/mediatek/mt8195/drivers/pmic/pmic_wrap_init.c
@@ -1517,6 +1517,36 @@ signed int pwrap_init(void)
 		PWRAPCRI("clear record command fail, ret=%x\n", sub_return);
 	PWRAPLOG("clear record command ok\n\r");
 
+         // for VCN18 enable high
+       pwrap_read_nochk(PMIC_RG_LDO_VCN33_2_EN_0_ADDR, &rdata);
+       PWRAPCRI("PMIC_RG_LDO_VCN33_2_EN_0_ADDR = 0x%x\n", rdata);
+
+       rdata &= ~(PMIC_RG_LDO_VCN33_2_EN_0_MASK << PMIC_RG_LDO_VCN33_2_EN_0_SHIFT);
+       rdata |= (1 << PMIC_RG_LDO_VCN33_2_EN_0_SHIFT);
+       sub_return = pwrap_write_nochk(PMIC_RG_LDO_VCN33_2_EN_0_ADDR, rdata);
+       if (sub_return != 0)
+       PWRAPCRI("VCN33 en0 enable command fail, ret=%x\n", sub_return);
+       PWRAPLOG("VCN33 en0 enable command ok\n");
+
+       pwrap_read_nochk(PMIC_RG_LDO_VCN33_2_EN_0_ADDR, &rdata);
+       PWRAPCRI("PMIC_RG_LDO_VCN33_2_EN_0_ADDR = 0x%x\n", rdata);
+
+       // for VCN18 enable high
+       pwrap_read_nochk(PMIC_RG_LDO_VCN33_2_EN_1_ADDR, &rdata);
+       PWRAPCRI("PMIC_RG_LDO_VCN33_2_EN_1_ADDR = 0x%x\n", rdata);
+
+       rdata &= ~(PMIC_RG_LDO_VCN33_2_EN_1_MASK << PMIC_RG_LDO_VCN33_2_EN_1_SHIFT);
+       rdata |= (1 << PMIC_RG_LDO_VCN33_2_EN_1_SHIFT);
+       sub_return = pwrap_write_nochk(PMIC_RG_LDO_VCN33_2_EN_1_ADDR, rdata);
+       if (sub_return != 0)
+       PWRAPCRI("VCN18 enable command fail, ret=%x\n", sub_return);
+       PWRAPLOG("VCN18 enable command ok\n");
+
+       pwrap_read_nochk(PMIC_RG_LDO_VCN33_2_EN_1_ADDR, &rdata);
+       PWRAPCRI("PMIC_RG_LDO_VCN33_2_EN_1_ADDR = 0x%x\n", rdata);
+
+
+	
 #ifdef PMIC_WRAP_MATCH_SUPPORT
 	/* enable matching mode */
 	PWRAPCRI("PMIC_WRAP_MONITOR_MODE = Matching Mode\n");
-- 
2.49.0

